{% extends "base.html" %}
{% block head %}
<style>
    .node rect {
        stroke-width: 2;
        stroke-linejoin: round;
        -cursor: pointer;
    }
    .node rect:hover {
        fill: orange;
    }
    .node text {
        font-family: dejavu_sanscondensed, Ariel, sans;
        -font-size: 82%;
        -font-family: sans-serif;
        font-size: 10px;
        text-anchor: middle;
        pointer-events: none;
    }
    p {
        font-family: sans-serif;
        -font-size: 1px;
    }
</style>
{% endblock %}
{% block content %}
<div class="main">
  <h1 class="page-header">Initiatives by Programme</h1>
    <p>Initiatives displayed by the Programme they belong to using a force layout.</p>
    <div id="tooltip" class="hidden">
        <table>
            <tr><th>Status:</th> <td id="tt_stat"></td></tr>
            <tr><th>Type:</th> <td id="tt_type"></td></tr>
            <tr><th>Category:</th> <td id="tt_cat"></td></tr>
            <tr><th>Programme:</th> <td id="tt_prog"></td></tr>
            <tr><th>Function:</th> <td id="tt_func"></td></tr>
            <tr><th>Start:</th> <td id="tt_start"></td></tr>
            <tr><th>End:</th> <td id="tt_end"></td></tr>
        </table>
    </div>
    <div id="diagram"></div>
    <p>Legend:</p>
    <img src="/static/img/byprog.legend.svg">
</div>
{% endblock %}
{% block foot %}
    <script type="text/javascript">
        var width = 960,
            height = 960;

        var link_len = 100,
            gravity = 0.1,
            charge = -200,
            collider = true,
            collide_padding = 1, // separation between circles
            collide_radius=45,
            tooltips = true;

        var force = d3.layout.force()
            .charge(charge)
            .gravity(gravity)
            .linkStrength(0.1)
            .linkDistance(function (link, i) {
                return (link.type === 'hard') ? link_len : 2*link_len;
            })
            //.chargeDistance(50)
            .size([width, height]);


        //---Sticky-------
        var node_drag = d3.behavior.drag()
                .on("dragstart", dragstart)
                .on("drag", dragmove)
                .on("dragend", dragend);

            function dragstart(d, i) {
                force.stop() // stops the force auto positioning before you start dragging
            }

            function dragmove(d, i) {
                d.px += d3.event.dx;
                d.py += d3.event.dy;
                d.x += d3.event.dx;
                d.y += d3.event.dy;
            }

            function dragend(d, i) {
                d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
                force.resume();
            }

            function releasenode(d) {
                d.fixed = false; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
                //force.resume();
            }
        //---End Sticky------


        /*init_grid.cols = 6;
        init_grid.rows = 12;
        init_grid.colw = 170;
        init_grid.rowh = 65;

        var w = init_grid.cols * init_grid.colw,
            h = init_grid.rows * init_grid.rowh + init_grid.rowh/2,
            inits = null,
            init_indx = {};

        var svg = d3.select("#diagram")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);

        svg.append("defs")
            .append("marker")
            .attr({
                id: "arrow",
                viewBox: "-20 -10 20 20",
                markerWidth: 12,
                markerHeight: 12,
                refx: 0,
                refy: 0,
                orient: "auto",
                markerUnits: "userSpaceOnUse"
            })
            .append("path")
            .attr({
                //d: "M2,2 L2,13 L8,7 L2,2",
                //d: "M0,0 L-13,7 L-13,-7 L0,0",
                d: "M-20,-8L0,0L-20,8",
                fill: "black",
            });


        function link_line(d) {
            var d1 = inits[d.source],
                d2 = inits[d.target],
                r1 = mk_init_rect(d1),
                xk = r1.cx, yk = r1.cy,
                r2 = mk_init_rect(d2),
                xl = r2.cx, yl = r2.cy,
                xm = r2.l, ym = r2.t,
                xn = r2.r, yn = r2.t,
                xp = r2.r, yp = r2.b,
                xq = r2.l, yq = r2.b,
                p = intersect_lineseg_rect(xk,yk, xl,yl, xm,ym, xn,yn, xp,yp, xq,yq);
            //console.log(d)
            if (!p) {
                p = {x: xl, y: yl};
            }
            if (d.type === 'hard') {
                d3.select(this)
                    .classed("hard", true)
                    .attr({
                        x1: xk, // d1.col * colw + colw/2,
                        y1: yk, // d1.row * rowh + rowh,
                        x2: p.x, // d2.col * colw + colw/2,
                        y2: p.y, // d2.row * rowh + rowh,
                        "marker-end": "url(#arrow)",
                    });
            } else {
                d3.select(this)
                    .classed("soft", true)
                    .attr({
                        x1: d1.byprog_col * init_grid.colw + init_grid.colw/2,
                        y1: d1.byprog_row * init_grid.rowh + init_grid.rowh,
                        x2: d2.byprog_col * init_grid.colw + init_grid.colw/2,
                        y2: d2.byprog_row * init_grid.rowh + init_grid.rowh,
                    });
            }
        }*/

        function mk_node(d) {
            var typ = mk_class(d.type),
                wth = 100,
                hgt = 40,
                grp = d3.select(this);

            grp.append("rect")
                .classed(typ, true)
                .classed(mk_class(d.category), true)
                .classed(mk_class(d.state), true)
                .attr({
                    x: -(wth/2), y: -(hgt/2), width: wth,  height: hgt,
                    rx: typ === "project" ? 5 : (typ === "activity" ? hgt/2 : 0),
                    ry: typ === "project" ? 5 : (typ === "activity" ? hgt/2 : 0),
                });
                //.on('click', function () {window.location.href = '/init/'+d._id;});

            grp.selectAll("text")
                .data(function(d) {
                    var ns = d.byprog_txt.split("|");
                    return ns.map(function(n) {
                        return {
                            col: d.byprog_col,
                            row: d.byprog_row,
                            n: ns.length,
                            name: n,
                        };
                    });
                })
                .enter()
                .append("text")
                .text(function(d) {return d.name})
                .attr({
                    x: function(d)    { return 0; },
                    y: function(d, i) { return -hgt/2 + (9 - d.n*6 + i*11) + hgt/2; },
                });

        }


        var svg = d3.select("#diagram").append("svg")
            .attr("width", width)
            .attr("height", height);

        svg.append("defs")
            .append("marker")
            .attr({
                id: "arrow",
                viewBox: "-20 -10 20 20",
                markerWidth: 12,
                markerHeight: 12,
                refx: 0,
                refy: 0,
                orient: "auto",
                markerUnits: "userSpaceOnUse"
            })
            .append("path")
            .attr({
                d: "M-20,-8L0,0L-20,8",
                fill: "black",
            });


        d3.json("/data/byprogf", function(data) {

            /*inits = data.inits;
            data.inits.forEach(function(ini) {
                init_indx[ini._id] = ini;
            });

            svg.selectAll("line.link")
                .data(data.links)
                .enter()
                .append("line")
                .each(link_line);

            var gs = svg.selectAll("g.init")
                     .data(data.inits)
                     .enter()
                     .append("g")
                     .classed("init", true);

            gs.each(init_rect);
            gs.each(init_text);
            gs.each(init_rag);*/

            /* Establish the dynamic force behavor of the nodes
            var force = d3.layout.force()
                            .nodes(gs)
                            .links(data.links)
                            .size([w,h])
                            .linkDistance([250])
                            .charge([-1500])
                            .gravity(0.3)
                            .start();

            gs.call(force.drag);*/

            force
              .nodes(data.inits)
              .links(data.links)
              .start();

            var link = svg.selectAll(".link")
              .data(data.links)
            .enter().append("line")
              .attr("class", function(d) { return "link " + d.type; })
              ;

            var node = svg.selectAll(".node")
              .data(data.inits)
            .enter().append("g")
              .classed("node", true)
              //.attr("class", function(d) { return "node " + mk_class(d.category) + " " + mk_class(d.state); } )
              //.attr("r", 10)
              .call(force.drag)
              .on('click', releasenode) //Added code ;
              .on('dblclick', connectedNodes); //Added code ;

            //node.append("title")
            //  .text(function(d) { return d.name; });

            node.each(mk_node);

            force.on("tick", function() {
                link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
                node.attr("transform", function(d) {
                        return "translate(" + d.x + " " + d.y + ")";
                    });
                if (collider) {
                    node.each(collide(0.5)); //Added
                }
            });

            //---Highlight-------

            //Toggle stores whether the highlighting is on
            var toggle = 0;

            //Create an array logging what is connected to what
            var linkedByIndex = {};
            for (i = 0; i < data.inits.length; i++) {
                linkedByIndex[i + "," + i] = 1;
            };
            data.links.forEach(function (d) {
                linkedByIndex[d.source.index + "," + d.target.index] = 1;
            });

            //This function looks up whether a pair are neighbours
            function neighboring(a, b) {
                return linkedByIndex[a.index + "," + b.index];
            }

            function connectedNodes() {

                if (toggle == 0) {
                    //Reduce the opacity of all but the neighbouring nodes
                    d = d3.select(this).node().__data__;
                    node.style("opacity", function (o) {
                        return neighboring(d, o) | neighboring(o, d) ? 1 : 0.2;
                    });

                    link.style("opacity", function (o) {
                        return d.index==o.source.index | d.index==o.target.index ? 1 : 0.2;
                    });

                    //Reduce the op

                    toggle = 1;
                } else {
                    //Put them back to opacity=1
                    node.style("opacity", 1);
                    link.style("opacity", 1);
                    toggle = 0;
                }
            }

            //---End Highlight---

            //---Collision------
            // Resolves collisions between d and all other circles.

            function collide(alpha) {
              var quadtree = d3.geom.quadtree(data.inits);
              return function(d) {
                var rb = 2*collide_radius + collide_padding,
                    nx1 = d.x - rb,
                    nx2 = d.x + rb,
                    ny1 = d.y - rb,
                    ny2 = d.y + rb;

                quadtree.visit(function(quad, x1, y1, x2, y2) {
                  if (quad.point && (quad.point !== d)) {
                    var x = d.x - quad.point.x,
                        y = d.y - quad.point.y,
                        l = Math.sqrt(x * x + y * y);
                      if (l < rb) {
                      l = (l - rb) / l * alpha;
                      d.x -= x *= l;
                      d.y -= y *= l;
                      quad.point.x += x;
                      quad.point.y += y;
                    }
                  }
                  return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                });
              };
            }
            //---End Collision---

            if (tooltips) {
                $('.node').qtip({
                    content: {
                        title: function() {
                            var d = this.context.__data__;
                            return d.name;
                        },
                        text: function() {
                            var d = this.context.__data__,
                                tt = d3.select("#tooltip");
                            //tt.select("#tt_name").text(d.name);
                            tt.select("#tt_stat").text(d.state);
                            tt.select("#tt_type").text(d.type);
                            tt.select("#tt_cat").text(d.category);
                            tt.select("#tt_prog").text(d.program.name);
                            tt.select("#tt_func").text(d['function']);
                            tt.select("#tt_start").text(d.start);
                            tt.select("#tt_end").text(d.end);
                            return tt.html();
                        },
                    },
                    style: {
                        classes: 'qtip-cluetip qtip-shadow'
                    },
                    position: {
                        my: 'left center',
                        at: 'center right',
                        viewport: $(window),
                        adjust: {
                            method: 'shift shift'
                        },
                    },
                });
            }
        });


    </script>
{% endblock %}