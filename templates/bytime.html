{% extends "base.html" %}
{% block head %}
<style>
    line.year, line.month, line.group, line.cluster {
        stroke: gray;
    }
    line.month {
        stroke-dasharray: 3,3;
    }
    text.group, text.cluster {
        font-size: 12px;
        text-anchor: middle;
        pointer-events: none;
    }
    line.dep {
        stroke: black;
        stroke-width: 2;
        opacity: 0.5;
    }
    line.backward {
        stroke: red;
    }
    text.year {
        font-size: 14px;
        text-anchor: left;
        pointer-events: none;
    }
    text.month, text.rag {
        font-size: 12px;
        text-anchor: middle;
        pointer-events: none;
    }
    rect.bar, path.bar {
        stroke: black;
        -pointer-events: none;
    }
    text.bar {
        font-size: 12.5px;
        text-anchor: left;
        pointer-events: none;
    }
    rect.row {
        fill: white;
    }
    rect.odd {
        fill: #EEE;
    }
    rect.row:hover {
        fill: #FDB;
    }
    rect.hilite {
        fill: #FDB;
    }
    rect.rag {
        fill: none;
        stroke: black;
    }
    rect.rag-red {
        fill: #D50000;
    }
    rect.rag-amber {
        fill: #D5D500;
    }
    rect.rag-green {
        fill: #00D500;
    }
</style>
{% endblock %}
{% block content %}
<div class="container-fluid">
<div class="main">
  <h1 class="page-header">Initiatives Timeline</h1>
    <div id="tooltip" class="hidden">
        <table>
            <tr><th>Status:</th> <td id="tt_state"></td></tr>
            <tr><th>Cluster:</th> <td id="tt_cluster"></td></tr>
            <tr><th>Start:</th> <td id="tt_start"></td></tr>
            <tr><th>End:</th> <td id="tt_end"></td></tr>
        </table>
    </div>
    <table>
        <tr>
            <td valign="top">
                <h3>Initiatives displayed on Gannt-like timeline</h3>
                <div id="view-choice"></div>
                <div id="group-choice"></div>
                <div id="deps-toggle"></div>
                <br/>
                <div id="diagram"></div>
                <div id="rag-text">
                <h3>Programme Status</h3>
                <p>The programme will determine the <em>RAG</em> (Red-Amber-Green)
                status for <em>time</em>, <em>scope</em> and <em>cost</em> for
                MHS TP initiatives. Be aware that
                there can be differences in the programme's perceived RAG-status
                compared to the initiative's own status. Comparing with the
                initiatives MHS TP is phasing out a large legacy system,
                transferring out all functionality from MHS to target applications.
                </p>
                <table>
                    <tr>
                        <td valign="top" width="30%">
                            <h4>Time</h4>
                            <p>MHS TP has a greater duration than an initiative
                            which means that there can be leeway between the
                            project's critical deadline and the critical deadline
                            for the programme. There can as well be dependencies
                            to critical milestones during the course of a project
                            which might be more important to the programme than
                            others. Managing a programme involves long term
                            strategic planning which might indicate that there
                            are time frames more or less flexible for achieving
                            the overall target.</p>
                        </td>
                        <td width="5%"></td>
                        <td valign="top" width="30%">
                            <h4>Scope</h4>
                            <p>The programme's requirements are described in terms
                            of outcomes and benefits. The scope is not as strongly
                            defined at the programme level and it can change during
                            the life cycle of the programme. A project's scope might
                            differ in the level of detail since there are different
                            interests from programme and business owner. This can
                            result in different RAG-statuses between the programme
                            and the project.</p>
                        </td>
                        <td width="5%"></td>
                        <td valign="top" width="30%">
                            <h4>Cost</h4>
                            <p>Projects typically have a straight-forward budget
                            related to their own deliverables and their own time
                            frame, while the programme budget consists of the sum
                            of all programme activities. The RAG status may differ
                            since a project budget deviation may not impact the
                            aggregated programme budget. The programme will
                            balance all deviations in its approved frame, and
                            only when the total approved frame is exceeded will
                            the programme status be affected.</p>
                        </td>
                    </tr>
                </table>
                </div>
            </td>
            <td valign="top">
                <h3>Filters</h3>
                <h4>Status</h4>
                <div id="state-filter"></div>

                <h4>Category</h4>
                <div id="category-filter"></div>

                <h4>Programme</h4>
                <div id="prog-filter"></div>

                <h4>IWOW Process</h4>
                <div id="proc-filter"></div>
                <button type="button" class="btn btn-default btn-xs" onclick="set_all_filters('process_id',true)">All</button>
                <button type="button" class="btn btn-default btn-xs" onclick="set_all_filters('process_id',false)">None</button>

                <h4>Tracker Frequency</h4>
                <div id="tracker-filter"></div>
            </td>
        </tr>
    </table>
</div>
</div>
{% endblock %}
{% block foot %}
    <script type="text/javascript">
        var ini_row = {},
            fst_yr = 14,
            lst_yr = 22,
            fst_date,
            lst_date,
            cols, rows,
            off = 380,
            grpw = 90,
            cluw = 20,
            ragw = 0,
            rowh = 19,
            txth = 11,
            colw, // = (1000 - off) / cols,
            w, // = off + cols * colw,
            h; // = (rows+1) * rowh;

        function ini_visible(ini) {
            if (ini == null) return false;
            //if (ini_row.length > 0 && ini_row[ini._id] == null) return false;

            if (!do_filter('INI', 'state', ini)) return false;
            if (!do_filter('INI', 'category', ini)) return false;

            if (!do_filter('INI', 'program_id', ini)) return false;
            if (!do_filter('INI', 'process_id', ini)) return false;

            if (!do_filter('INI', 'tracker_freq', ini)) return false;

            if (choice.view === 'year') {
                //if (ini.start_date == null) return false;
                if (ini.end_date == null) return false;
                if (ini.start_date != null && cmp_date(lst_date, mk_date(ini.start_date)) < 0) return false;
                if (cmp_date(fst_date, mk_date(ini.end_date)) > 0) return false;
            }

            return true;
        }
        function dep_visible(dep) {
            if (!toggle.deps) return false;
            if (dep == null) return false;

            var ini1 = index.ini[dep.from_init_id],
                ini2 = index.ini[dep.to_init_id];

            if (!ini_visible(ini1)) return false;
            if (!ini_visible(ini2)) return false;

            if (ini1.end == null || ini2.start == null) return false;

            return true;
        }
        function group_inis(inis) {
            var grps,
                grp_ord;

            switch (choice.group) {
                case 'func':
                    grps = _.groupBy(inis, 'function');
                    grp_ord = _.keys(grps).sort();
                    break;
                case 'proc':
                    inis = _.filter(inis, function (ini) {
                        return ini.process != null;
                    });
                    inis = _.sortBy(inis, 'roadmap_ord');
                    grps = _.groupBy(inis, function (ini) {
                        return ini.process.title;
                    });
                    _.each(grps, function (v, k) {
                        var val =_.sortBy(v, function (ini) {
                            return ini.cluster ? ini.cluster.roadmap_ord : 100;
                        });
                        grps[k] = val;
                    });
                    grp_ord = _.filter(_.pluck(_.sortBy(data.process, 'roadmap_ord'), 'title'), function (x) {
                        return _.contains(_.keys(grps), x);
                    });
                    break;
                case 'clus':
                    inis = _.filter(inis, function (ini) {
                        return ini.cluster != null;
                    });
                    inis = _.sortBy(inis, 'roadmap_ord');
                    grps = _.groupBy(inis, function (ini) {
                        return ini.cluster.name;
                    });
                    //grp_ord = _.keys(grps).sort();
                    grp_ord = _.filter(_.pluck(_.sortBy(data.cluster, 'roadmap_ord'), 'name'), function (x) {
                        return _.contains(_.keys(grps), x);
                    });
                    break;
            }

            return _.map(grp_ord, function (key) {
                return [key, grps[key]];
            });
        }

        function row_rect(d, i) {
            d3.select(this)
                .classed("row", true)
                .classed("odd", (i+1)%2)
                .attr({
                    x: grpw,
                    y: (i+1) * rowh,
                    width: off + cols * colw + 3 * ragw - grpw,
                    height: rowh,
                    id: 'row' + i,
                });
        }
        function rag_rect(rect, i, d, f) {
            rect.classed("rag", true)
                .classed("rag-red", d[f] === 'red')
                .classed("rag-amber", d[f] === 'amber')
                .classed("rag-green", d[f] === 'green')
                .attr({
                    x: off + (cols * colw) + (i * ragw) + 3,
                    y: ini_row[d._id] * rowh + 3,
                    width: ragw - 6,
                    height: rowh - 6,
                });
        }

        function init_bar(d, i) {
            var l = off + d.sc * colw,
                r = off + d.ec * colw,
                t = (i+1) * rowh + 3,
                b = t + rowh - 6,
                path;

            if (d.ec) {
                path = fmt("M {0} {1} {3} {1} {4} {5} {3} {2} {0} {2} {6}", l,t,b,r-rowh/2, r, t+(rowh-4)/2, d.ini.start ? 'Z' : '');
                //path = fmt("M {0} {1} {3} {1} {4} {5} {3} {2} {0} {2} {6}", l,t,b,r, d.ini.start ? 'Z' : '');

                d3.select(this)
                    .classed("bar", true)
                    .classed(mk_class(d.ini.category), true)
                    .attr('d', path)
                    .on("mouseover", function() {
                        d3.select('#row'+i).classed('hilite', true);
                    })
                    .on("mouseout", function() {
                        d3.select('#row'+i).classed('hilite', false);
                    })
                    .on('click', function () {window.location.href = '/init/'+d.ini._id;});
            } else if (d.sc) {
                r = off + cols * colw;
                path = fmt("M {0} {2} {1} {2} {1} {3} {0} {3}", r, l, t, b);

                d3.select(this)
                    .classed("bar", true)
                    .classed(mk_class(d.ini.category), true)
                    .attr('d', path)
                    .on("mouseover", function() {
                        d3.select('#row'+i).classed('hilite', true);
                    })
                    .on("mouseout", function() {
                        d3.select('#row'+i).classed('hilite', false);
                    });
            }
        }
        function dep_line_full(d) {
            var d1 = index.ini[d.from_init_id],
                d2 = index.ini[d.to_init_id],
                s = mk_fyt(d1.end, true),
                e = mk_fyt(d2.start, false),
                sc = s ? fyt_col(s,fst_yr) : undefined,
                ec = e ? fyt_col(e,fst_yr) : undefined,
                sr = ini_row[d1._id],
                er = ini_row[d2._id];

            if (sc && ec && sr && er) {
                d3.select(this)
                    .classed("dep", true)
                    //.classed("backward", sc > ec + .34)
                    .attr({
                        x1: off + sc * colw - colw/6,
                        y1: sr * rowh + rowh/2,
                        x2: off + ec * colw + colw/6,
                        y2: er * rowh + rowh/2,
                        "marker-start": "url(#circle)",
                        "marker-end": "url(#arrow)",
                    });
            }
        }
        function clamp(x, lo, hi) {
            if (x < lo) return lo;
            if (x > hi) return hi;
            return x;
        }
        function dep_line_year(d) {
            var d1 = index.ini[d.from_init_id],
                d2 = index.ini[d.to_init_id],
                s = mk_date(d1.end_date),
                e = mk_date(d2.start_date),
                fst_mnth = first_month(),
                sc = s ? clamp(date_col(s,fst_mnth,12),0,12) : undefined,
                ec = e ? clamp(date_col(e,fst_mnth,12),0,12) : undefined,
                sr = ini_row[d1._id],
                er = ini_row[d2._id];

            if (sc != null && ec != null && sr != null && er != null) {
                d3.select(this)
                    .classed("dep", true)
                    //.classed("backward", sc > ec + .34)
                    .attr({
                        x1: off + sc * colw - colw/6,
                        y1: sr * rowh + rowh/2,
                        x2: off + ec * colw + colw/6,
                        y2: er * rowh + rowh/2,
                        "marker-start": "url(#circle)",
                        "marker-end": "url(#arrow)",
                    });
            }
        }
        function init_text(d, i) {
            d3.select(this)
                .classed("bar", true)
                .text(d.ini.name)
                .attr({
                    x: grpw+3,
                    y: (i+1) * rowh + txth + (rowh-txth)/2,
                });
        }
        function year_text(d) {
            d3.select(this)
                .text(d.name)
                .classed("year", true)
                .attr({
                    x: d.x + 2,
                    y: 12,
                });
        }
        function rag_text(d) {
            d3.select(this)
                .text(d.name)
                .classed("rag", true)
                .attr({
                    x: d.x + (ragw / 2),
                    y: 12,
                });
        }
        function year_line(d) {
            d3.select(this)
                .classed("year", true)
                .attr({
                    x1: d.x,
                    y1: 0,
                    x2: d.x,
                    y2: (rows+1) * rowh,
                });
        }
        function month_text(d) {
            d3.select(this)
                .text(d.name)
                .classed("month", true)
                .attr({
                    x: d.x + colw/2,
                    y: h - 3, //10,
                });
        }
        function month_line(d) {
            d3.select(this)
                .classed("month", true)
                .attr({
                    x1: d.x,
                    y1: rowh,
                    x2: d.x,
                    y2: (rows+1) * rowh,
                });
        }
        function group_line(d) {
            d3.select(this)
                .classed("group", true)
                .attr({
                    x1: 0,
                    y1: (d.row + 0) * rowh,
                    x2: off + cols * colw + 3 * ragw,
                    y2: (d.row + 0) * rowh,
                });
        }
        function group_text(grp) {
            if (grp.rows > 0) {
                var g = d3.select(this),
                    rect = g.append('rect')
                            .attr({
                                x: 0,
                                y: grp.row * rowh,
                                width: grpw-3,
                                height: grp.rows * rowh,
                                fill: 'none'
                            }),
                    text = g.append('text')
                            .text(grp.name)
                            .classed("group", true);

                d3plus.textwrap()
                      .container(text)
                      .padding(0)
                      .valign("middle")
                      //.rotate(-90)
                      .draw();
            }
        }
        function cluster_line(clu) {
            d3.select(this)
                .classed("cluster", true)
                .attr({
                    x1: w - cluw,
                    y1: clu.row * rowh,
                    x2: w,
                    y2: clu.row * rowh,
                });
        }
        function cluster_text(clu) {
            if (clu.rows > 0) {
                var g = d3.select(this),
                    rect = g.append('rect')
                            .attr({
                                x: w - cluw,
                                y: clu.row * rowh,
                                width: cluw-3,
                                height: clu.rows * rowh,
                                fill: 'none'
                            }),
                    text = g.append('text')
                            .text(clu.name.replace('&', 'and'))
                            .classed("cluster", true);

                d3plus.textwrap()
                      .container(text)
                      .padding(0)
                      .valign("middle")
                      .rotate(-90)
                      .draw();
            }
        }

        function first_month() {
            var now = mk_date_now(),
                fst_mnth = Math.floor(now.getMonth() / 4) * 4;
            return mk_date(now.getFullYear(), fst_mnth, 1)
        }

        // This is called by the filter functions to re-draw the diagram
        function render() {
            ini_row = {};

            if (choice.view === 'year') {
                ragw = rowh;
                cols = 12;
                var now = mk_date_now(),
                    fst_mnth = Math.floor(now.getMonth() / 4) * 4;
                fst_date = mk_date(now.getFullYear(), fst_mnth, 1);
                lst_date = mk_date(now.getFullYear()+1, fst_mnth, 1);
            } else {
                ragw = 0;
                cols = lst_yr - fst_yr + 1; //0;
            }
            colw = (900 - off) / cols;

            var inits = data.initiative.filter(ini_visible),
                grps = group_inis(inits),
                groups = [],
                clusters = [],
                i = 0,
                f = '-';

            inits = [];
            _.each(grps, function (grp) {
                var key = grp[0],
                    inis = grp[1];

                groups.push({name: key, row: i+1, rows: inis.length});

                _.each(inis, function (ini) {
                    ini_row[ini._id] = i+1;
                    inits.push(ini);
                    i++;
                })
            });
            groups.push({name: '', row: i+1, rows: 0});

            if (choice.group === 'proc') {
                var clu_id = null,
                    clu = null;
                _.each(inits, function (ini) {
                    if (clu != null) {
                        clu.rows++;
                    }
                    if ((ini.cluster == null && clu_id != null) || (ini.cluster != null && ini.cluster._id !== clu_id)) {
                        if (clu != null) {
                            clusters.push(clu);
                            clu_id = null;
                            clu = {name: '?', row: ini_row[ini._id], rows: 0};
                        }
                        if (ini.cluster != null) {
                            clu_id = ini.cluster._id;
                            clu = {name: ini.cluster.name, row: ini_row[ini._id], rows: 0};
                        }
                    }
                });
                if (clu != null) {
                    clusters.push(clu);
                }
                clusters.push({name: '', row: i+1, rows: 0});
                cluw = 40;
            } else {
                cluw = 0;
            }

            rows = inits.length;
            w = off + cols * colw + (3 * ragw) + cluw;
            h = (rows+2) * rowh;
            $("#rag-text").width(w);

            d3.select("#diagram svg").remove();

            var svg = d3.select("#diagram")
                        .append("svg")
                        .attr("width", w+1+40)
                        .attr("height", h+1),
                defs = svg.append("defs");

            d3_def_arrow(defs, 'black');
            d3_def_circle(defs, 'black');

            var bars = [],
                years = [],
                months = [];

            if (choice.view === 'year') {
                var mnth_name = [
                        'Jan','Feb','Mar','Apr','May','Jun',
                        'Jul','Aug','Sep','Oct','Nov','Dec'
                    ],
                    now = mk_date_now(),
                    fst_mnth = Math.floor(now.getMonth() / 4) * 4,
                    months = _.map(_.range(12), function (i) {
                                var m = (fst_mnth + i) % 12;
                                return {
                                    x: off + i * colw,
                                    name: mnth_name[m]
                                };
                            }),
                    year = now.getFullYear() - 2000,
                    bar_inis = _.filter(inits, function (ini) {
                        return ini.start_date != null && ini.end_date != null;
                    });

                years = [
                            {x: off, name: 'FY' + year},
                            {x: off + ((8 - fst_mnth) % 12) * colw, name: 'FY' + (year+1)},
                        ];

                bars = _.map(inits, function (ini) {
                    var s = mk_date(ini.start_date),
                        e = mk_date(ini.end_date),
                        f = mk_date(year, fst_mnth, 1);
                    return {
                        ini: ini,
                        sc: s != null ? Math.max(0, date_col(s,f,12)) : null,
                        ec: e != null ? Math.min(cols, date_col(e,f,12)) : null,
                    };
                });
            } else {
                years = _.map(_.range(cols), function (i) {
                            return {
                                x: off + i * colw,
                                name: 'FY' + (fst_yr + i),
                            }
                        });

                bars = _.map(inits, function (ini) {
                    var s = mk_fyt(ini.start, false),
                        e = mk_fyt(ini.end, true);
                    return {
                        ini: ini,
                        sc: fyt_col(s,fst_yr),
                        ec: fyt_col(e,fst_yr),
                    };
                });
            }

            var ini_gs = d3_add(svg, "g", bars, "g");
            ini_gs.append("rect").each(row_rect);

            d3_add(svg, "text.month", months, "text", month_text);
            d3_add(svg, "line.month", months, "line", month_line);
            d3_add(svg, "text.year", years, "text", year_text);
            d3_add(svg, "line.year", years, "line", year_line);

            ini_gs.append("path").each(init_bar);
            ini_gs.append("text").each(init_text);

            d3_add(svg, "line.group", groups, "line", group_line);
            d3_add(svg, "text.group", groups, "g", group_text);

            d3_add(svg, "line.cluster", clusters, "line", cluster_line);
            d3_add(svg, "text.cluster", clusters, "g", cluster_text);

            //ini_gs.each(function (d,i) {
            //    mk_ini_rag_g(d, d3.select(this), off-30, (i+1) * rowh + 2);
            //});
            if (choice.view === 'year') {
                //ini_gs.append("rect").each(function (d) {rag_rect(d3.select(this),0,d,'tp_rag_t');});
                //ini_gs.append("rect").each(function (d) {rag_rect(d3.select(this),1,d,'tp_rag_s');});
                //ini_gs.append("rect").each(function (d) {rag_rect(d3.select(this),2,d,'tp_rag_c');});
                var rag_text_data = [
                    {name: 'T', x: off + (cols * colw) + (0 * ragw)},
                    {name: 'S', x: off + (cols * colw) + (1 * ragw)},
                    {name: 'C', x: off + (cols * colw) + (2 * ragw)},
                ];
                d3_add(svg, "text.rag", rag_text_data, "text", rag_text);

                d3_add(svg, "rect.tp_rag_t", inits, "rect", function (d) {rag_rect(d3.select(this),0,d,'tp_rag_t');});
                d3_add(svg, "rect.tp_rag_s", inits, "rect", function (d) {rag_rect(d3.select(this),1,d,'tp_rag_s');});
                d3_add(svg, "rect.tp_rag_c", inits, "rect", function (d) {rag_rect(d3.select(this),2,d,'tp_rag_c');});
            }

            d3_add(svg, "line.dep", data.dependency.filter(dep_visible), "line", choice.view === 'year' ? dep_line_year : dep_line_full);

            $('.bar').qtip({
                content: {
                    title: function() {
                        var d = this.context.__data__;
                        return d.name;
                    },
                    text: function() {
                        var d = this.context.__data__.ini,
                            c = d.cluster,
                            s = mk_fyt(d.start, false),
                            e = mk_fyt(d.end, true),
                            tt = d3.select("#tooltip");
                        tt.select("#tt_state").text(enum_vals.ini_state[d.state]);
                        tt.select("#tt_cluster").text(c ? c.name : '');
                        tt.select("#tt_start").text(s ? s.fiscal_str() : '');
                        tt.select("#tt_end").text(e ? e.fiscal_str() : '');
                        return tt.html();
                    },
                },
                style: {
                    classes: 'qtip-cluetip qtip-shadow'
                },
                position: {
                    my: 'bottom center',
                    at: 'top center',
                    viewport: $(window),
                    adjust: {
                        method: 'shift flip'
                    },
                }
            });
        }

    //==========================================================================

    mk_choice_inline('group', 'group-choice', [
        {val: 'proc', txt: 'Group by IWOW Process'},
        {val: 'func', txt: 'Group by Functional Area'},
        {val: 'clus', txt: 'Group by Business Change Area'},
    ], 'proc');

    mk_choice_inline('view', 'view-choice', [
        {val: 'year', txt: 'View this Year'},
        {val: 'full', txt: 'View Full Timeline'},
    ], 'year');

    mk_toggle_inline('deps', 'Show Dependencies', false, 'deps-toggle');

    d3.json("/data/bytime", function(bytime_data) {
        set_data(bytime_data);

        mk_filter('INI', 'state', 'state-filter', ['pending','started','rollout','closed']);
        mk_filter('INI', 'category', 'category-filter');
        mk_filter('INI', 'program_id', 'prog-filter');
        mk_filter('INI', 'process_id', 'proc-filter');
        mk_filter('INI', 'tracker_freq', 'tracker-filter');

        mk_index('ini', data.initiative);
        //mk_index('proc', data.process);

        render();
    });
</script>
{% endblock %}
